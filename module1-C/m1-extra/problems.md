# üìå Module 1 ‚Äî Problem Solving with C (NQT-Focused)

This module is **not about finishing syllabus**. It is about **building core logic patterns** that repeatedly appear in:

- TCS NQT
- campus coding rounds
- basic technical interviews

Do **only these problems**, properly. Nothing extra.

---

## ‚ùå What NOT to Do

- Do NOT solve 200 random questions
- Do NOT chase advanced C tricks
- Do NOT overuse pointers
- Do NOT jump topics for speed

> **Patterns matter more than quantity.**

---

## ‚úÖ What Success Looks Like

- Zero hesitation with conditions & loops
- Ability to write logic before code
- Confidence when seeing a new basic problem

If you achieve this, Module 1 has done its job.

---

# üß± SECTION 1: INPUT‚ÄìOUTPUT & CONDITIONS (FOUNDATION)

Do these until they feel **boring**.

<!-- 1. Read two numbers, print the larger
2. Check whether a number is even or odd
3. Check whether a number is positive, negative, or zero
4. Check whether a year is a leap year
5. Check whether a character is a vowel or consonant
6. Find grade from marks
7. Simple calculator using `switch` -->

**Goal:** No hesitation with `if‚Äìelse`, `else if`, `switch`.

---

# üîÅ SECTION 2: LOOPS (MOST IMPORTANT)

These are **non-negotiable**.

## Number-based Problems

<!-- 1. Print numbers from 1 to N
2. Find sum of first N numbers
3. Count digits in a number
4. Reverse a number
5. Check palindrome number
6. Check Armstrong number
7. Check prime number
8. Print all prime numbers in a range -->

## Pattern Logic

<!-- 9. Print multiplication table
10. Print basic star patterns

- Square
- Right-angled triangle
 -->

**Goal:** Loop + condition thinking must become **automatic**.

---

# üî¢ SECTION 3: MATHEMATICAL LOGIC (NQT FAVORITE)

<!-- These will feel hard at first. That‚Äôs expected.

1. GCD (Euclid‚Äôs method)
2. LCM using GCD
3. Factorial (using loop + function)
4. Fibonacci series
5. Power of a number (without using `pow`)
6. Sum of digits of a number -->

> If these feel uncomfortable ‚Üí you are learning correctly.

---

# üì¶ SECTION 4: ARRAYS (CRITICAL FOR DSA LATER)

Do NOT rush this section.

<!-- 1. Read and print array elements
2. Find largest and smallest element
3. Find sum and average of array elements
4. Count even and odd elements
5. Reverse an array
6. Linear search in array
7. Sort array (Bubble sort only)
8. Find second largest element -->

**Goal:** Indexing clarity and loop control.

---

# üî§ SECTION 5: STRINGS (EASY MARKS)

<!-- 1. Find length of string (without `strlen`)
2. Reverse a string
3. Check palindrome string
4. Count vowels, consonants, and spaces
5. Copy one string to another manually
6. Compare two strings (without `strcmp`) -->

These come **directly** in NQT.

---

# üß© SECTION 6: FUNCTIONS (STRUCTURE THINKING)

Do NOT add new problems here.

Convert **existing problems** into functions:

<!-- - `factorial()`
- `isPrime()`
- `gcd()`
- `isPalindrome()` -->

**Goal:** Learn decomposition, not new logic.

---

# üëâ SECTION 7: POINTERS (LIMITED USE)

Only do the following:

1. Swap two numbers using pointers
2. Access array elements using pointer
3. Pass array to function using pointer

‚ùå Skip:

- Pointer arithmetic tricks
- Double pointers

Low ROI for now.

---

# üö´ SECTION 8: FILE HANDLING & STRUCTURES

**Ignore for now.**

Reason:

- Low weight in NQT
- High cognitive load for beginners

---

# üß† HOW TO PRACTICE EACH PROBLEM (MANDATORY PROCESS)

For **every single problem**:

1. Write logic in plain English
2. Dry run with sample input
3. Write the C code
4. Remove extra `printf` debugging
5. Rewrite the same problem after 2 days **without looking**

> If you skip step 1, you are lying to yourself.

---

# ‚è±Ô∏è DAILY TARGET

- **2‚Äì3 problems per day**, fully understood
- Not 10 half-done ones

Slow + correct **beats** fast + confused.

---
